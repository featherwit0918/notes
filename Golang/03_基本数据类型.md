## 基本数据类型

Go语言中有丰富的数据类型, 除了基本数据的整型、浮点型、布尔型、字符串外, 还有数组、切片、结构体、函数、map、通道(channel)等。Go语言的基本类型和其他语言大同小异



### 整型

整型分为两大类: 按长度分为: int8、int16、int32、int64 对应的无符号整型: uint8、uint16、uint32、uint64, `uint8`也就是熟知的`byte`, `int16`对应C语言的`short`型, `int64`对应C语言中的`lang`型

<img src="https://gitee.com/featherwit0918/imgstorage/raw/master/20210810150239.png" width="60%">

#### 特殊整型

<img src="https://gitee.com/featherwit0918/imgstorage/raw/master/20210810150522.png" width="60%">

> 注意: 在使用`int`和`uint`类型时, 不能假定它是32位或64位的整型, 而是考虑`int`和`uint`可能在不同平台上的差异
>
> &nbsp;
>
> 注意事项: 获取对象的长度的内建`len()`函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中, 切片或map的元素数量都可以用`int`来表示。在涉及二进制传输、读写文件的结构描述时, 为了保持文件的结构不会受到不同编译目标平台字节长度的影响, 不要使用`int`和`uint`

#### 数字字面量语法(Number literals syntax)

Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：

`v := 0b00101101`， 代表二进制的 101101，相当于十进制的 45。 `v := 0o377`，代表八进制的 377，相当于十进制的 255。 `v := 0x1p-2`，代表十六进制的 1 除以 2²，也就是 0.25。

而且还允许我们用 `_` 来分隔数字，比如说： `v := 123_456` 表示 v 的值等于 123456。

我们可以借助fmt函数来将一个整数以不同进制形式展示。

```go
package main

import "fmt"

func main() {

	// 十进制
	n := 10
	fmt.Printf("%b\n", n)
	fmt.Printf("%d\n", n)

	// 八进制
	m := 075
	fmt.Printf("%d\n", m)
	fmt.Printf("%o\n", m)

	// 十六进制
	f := 0xff
	fmt.Printf("%d\n", f)
	fmt.Printf("%x\n", f)

}
```



### 浮点型

Go语言支持两种浮点型数: `float32`和`float64`。这两种浮点型数据格式遵循`IEEE 754`标准: `float32`的浮点数的最大范围约为`3.4e38`, 可以使用常量定义: `math.MaxFloat32`。`float64`的浮点数的最大范围约为`1.8e308`, 可以使用一个常量定义:`max.MaxFloat64`

打印浮点数时, 可以使用`fmt`包配合动词`%f`, 代码如下

```go
package main
import (
        "fmt"
        "math"
)
func main() {
        fmt.Printf("%f\n", math.Pi)
        fmt.Printf("%.2f\n", math.Pi)
}
```



### 复数

complex32和complex64

```go
var c1 complex64
c1 = 1 + 2i

var c2 complex128
c2 = 2 + 3i

fmt.Println(c1)
fmt.Println(c2)
```

复数有实部和虚部, complex64的实部和虚部为32位, complex128的实部和虚部为64位



### 布尔值

Go语言中以`bool`类型进行声明布尔型数据, 布尔型数据只有`true(真)`和`false(假)`两个值

>注意:
>
>1. 布尔类型变量的默认值为`false`
>2. Go语言中不允许将整型强制转换为布尔型
>3. 布尔型无法参与数值运算, 也无法与其他类型进行转换



### 字符串

Go语言中的字符串以原生数据类型出现, 使用字符串就像使用其他原生数据类型(int, bool, float32, float64等)一样。Go语言里的字符串的内部实使用`UTF-8`编码。字符串的值为`双引号("")`中的内容, 可以在Go语言的原码中直接添加非ASCII码字符

#### 字符串转义符

Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。

<img src="https://gitee.com/featherwit0918/imgstorage/raw/master/20210810152812.png" width="60%">

```go
package main

import (
	"fmt"
)

func main(){
    // 打印windows平台下的路径 c:\code\go.exe
	fmt.Println("c:\\code\\go.exe")
}
```

#### 多行字符串

Go语言中要定义一个多行字符串时，就必须使用`反引号`字符：

```go
s1 := `第一行
第二行
第三行
`

fmt.Println(s1)
```

> 反引号间换行将被作为字符串中的换行, 但是所有的转义字符均无效, 文本会原样输出

#### 字符串的常用操作

<img src="https://gitee.com/featherwit0918/imgstorage/raw/master/20210810153226.png" width="60%">

```go
package main

import (
	"fmt"
	"strings"
)

// 字符串常用操作
func main() {
	s1 := "hello"
	fmt.Println(len(s1))
	s2 := "Hello世界"
	fmt.Println(len(s2))

	// 拼接字符串
	fmt.Println(s1 + s2)
	s3 := fmt.Sprintf("%s - %s", s1, s2)
	fmt.Println(s3)

	// 字符串的分割
	s4 := "How do you do"
	fmt.Println(strings.Split(s4, " "))
	fmt.Printf("%T\n", strings.Split(s4, " "))

	// 判断是否包含
	fmt.Println(strings.Contains(s4, "do"))

	// 判断前缀
	fmt.Println(strings.HasPrefix(s4, "How"))
	// 判断后缀
	fmt.Println(strings.HasSuffix(s4, "do"))

	// 判断子串的位置
	fmt.Println(strings.Index(s4, "do"))
	// 判断子串出现的位置
	fmt.Println(strings.LastIndex(s4, "do"))

	// 拼接
	s5 := []string{"how", "do", "you", "do"}
	fmt.Println(s5)
	fmt.Println(strings.Join(s5, "+"))
}
```



### byte和rune类型

组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：

```go
var a = '中'
var b = '国'
```

Go 语言的字符有以下两种: 

1. `byte`类型，是`uint8`类型的别名，代表了`ASCII码`的一个字符。
2. `rune`类型，是`int8`类型的别名。

```go
package main

import "fmt"

// 字符
func main() {

	// byte uint8的别名 ASCII码
	// rune int8的别名
	var c1 byte = 'c'
	var c2 rune = 'c'
	fmt.Println(c1, c2)
	fmt.Printf("c1:%T c2:%T\n", c1, c2)

}
```

当需要处理中文、日文或者其他复合字符时，则需要用到`rune`类型。`rune`类型实际是一个`int32`

Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。

```go
// 遍历字符串
func traversalString() {
	s := "hello世界"
	for i := 0; i < len(s); i++ {
		fmt.Printf("%c\n", s[i])
	}

	fmt.Println()

	for _, r := range s {
		fmt.Println("%c\n", r)
	}
}
```

输出：

```bash
104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 
104(h) 101(e) 108(l) 108(l) 111(o) 27801(世) 27827(界) 
```

因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

字符串底层是一个byte数组，所以可以和`[]byte`类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。

#### 修改字符串

要修改字符串，需要先将其转换成`[]rune`或`[]byte`，完成后再转换为`string`。无论哪种转换，都会重新分配内存，并复制字节数组。

```go
func changeString() {
	s1 := "big"
	// 强制类型转换
	byteS1 := []byte(s1)
	byteS1[0] = 'p'
	fmt.Println(string(byteS1))

	s2 := "白萝卜"
	runeS2 := []rune(s2)
	runeS2[0] = '红'
	fmt.Println(string(runeS2))
}
```



### 类型转换

Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。

强制类型转换的基本语法如下:

```go
T(表达式)
```

其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.

比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。

```go
func sqrtDemo() {
	var a, b = 3, 4
	var c int
	// math.Sqrt()接收的参数是float64类型，需要强制转换
	c = int(math.Sqrt(float64(a*a + b*b)))
	fmt.Println(c)
}
```

>类型转化注意点：
>
>1）Go中数据类型的转换可以从 数值范围大 > 数值范围小，反之也可，注意别`溢出`
>
>2）被转化的变量存储的数值，变量本身的数据类型没变化

```go
package main
import "fmt"
func main() {
    var n1 int32 = 12
    var n2 int64 = 10
    //n3:=n1+n2 //不同类型之间无法计算,需要强转
    n3 := int64(n1) + n2
    fmt.Println(n3)
}
```

#### Go基本数据类型与string转换

- fmt.Printf("%参数", 表达式)

```go
package main
import "fmt"
func main() {
    var num1 int = 66
    var num2 float64 = 25.25
    var b bool = true
    var myChar byte = 'c'
    
    //%q 单引号
    //%d 十进制表示
    str1 := fmt.Sprintf("%d", num1)
    fmt.Printf("str1 type %T str=%q\n", str1, str1)
    
    //%f 有小数点
    str2 := fmt.Sprintf("%f", num2)
    fmt.Printf("str2 type %T str2=%q\n", str2, str2)

    //%t 布尔值
    str3 := fmt.Sprintf("%t", b)
    fmt.Printf("str3 type %T str3=%q\n", str3, str3)
    
    //%c Unicode码对应的字符
    str4 := fmt.Sprintf("%c", myChar)
    fmt.Printf("str4 type %T str4=%q\n", str4, str4)
}
```

- fmt.Strconv

```go
package main
import (
    "fmt"
    "strconv"
)
func main() {
    var num1 int = 99
    var num2 float64 = 66.66
    var b1 bool = true
    
    str1 := strconv.FormatInt(int64(num1), 10)
    fmt.Printf("str1类型是%T str1=%q\n", str1, str1)
    
    //参数解释
    // f 格式
    // 10 小数位保留10位
    // 64  表示float64
    str2 := strconv.FormatFloat(num2, 'f', 10, 64)
    fmt.Printf("str2类型是%T str2=%q\n", str2, str2)
    
    str3 := strconv.FormatBool(b1)
    fmt.Printf("str3类型是%T str3=%q\n", str3, str3)
    
    //Itoa，将int转为string
    var num3 int64 = 1123
    str4 := strconv.Itoa(int(num3))//必须强转int()
    fmt.Printf("str4类型是%T str4=%q\n", str4, str4)
}
```

#### String类型转基本数据类型

```go
func ParseBool(str string)(bool, error)
func ParseFloat(s string, bitSize int)(float64, error)
func ParseInt(s string, base int, bitSize int)(i int64, error)
func ParseUint(s string, base int, bitSize int)(uint64, error)
```

```go
package main
import (
    "fmt"
    "strconv"
)
func main() {
    /*
        ParseBool，ParseFloat，ParseInt和ParseUint将字符串转换为值
        如转换失败，返回新类型默认值
    */
    
    var str1 string = "true"
    var b1 bool
    /*
        strconv.ParseBool(str1)函数返回2个值（value bool,err error)
    */
    b1, _ = strconv.ParseBool(str1)
    fmt.Printf("b 值类型= %T  b值=%v\n", b1, b1)
    
    var str2 string = "1234"
    var num1 int64
    //func ParseInt（s string，base int，bitSize int）（i int64，err error）
    num1, _ = strconv.ParseInt(str2, 10, 64)
    fmt.Printf("num1类型：%T num2值：%v\n", num1, num1)
    
    var str3 string = "123.456"
    var float1 float64
    //func ParseFloat（s string，bitSize int）（float64，error）
    float1, _ = strconv.ParseFloat(str3, 64)
    fmt.Printf("float1类型：%T  float1值：%v", float1, float1)
}
```

